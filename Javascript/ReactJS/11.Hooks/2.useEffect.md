# useEffect(callback - thực hiện side effect, [dependency])
## Kiến thức cần ôn tập:
- **Events**: add/ remove event listener
- **Observer pattern**: subrible/ unsubribe
  - Observer Design Pattern định nghĩa mối quan hệ một-nhiều giữa các đối tượng sao cho khi một đối tượng thay đổi trạng thái, tất cả các đối tượng phụ thuộc vào nó đều được thông báo và cập nhật tự động.
- **Closure**: (khái niệm hàm đóng) la 1 ham co the ghi nho noi no duoc tao va truy cap toi bien o ben ngoai pham vi cua no
- **Timers**: setInternal, setTimeout, clearInterval, clearTimeout
- **useState**
- Mounted/ unmounted
- **Toán tử so sánh strict**: ===
- Call API

## Cú pháp dùng:
1. useEffect(callback, [dependency])
   - *dependency là 1 biến chứa giá trị*
   - *Callback sẽ được gọi lại khi deps thay đổi*
2. useEffect(callback, [])
   - *Chỉ gọi callback 1 lần khi component mounted*
3. [**Ít dùng**] useEffect(callback) 
   - *gọi callback mỗi khi re-render component*
   - *gọi callback sau khi component thêm element vào DOM (tạo code HTML trước mới gọi hàm)*

**Lưu ý**:
- Callback luôn được gọi sau khi component mounted

## Cách dùng
Sử dụng khi: muốn thực hiện các side effect (*thuật ngữ chỉ phần mềm có dữ liệu bị thay đổi khi có tác động xảy ra*) => gọi `side` là vì cần **ưu tiên luồng tạo UI cho người dùng**, còn phần sửa dữ liệu là phụ.

## Thực hành (tạo thêm file component.js)
1. Update DOM (thay đổi tiêu đề khi add input)
    ```jsx
    export default function Content() {
        let [title, setTitle] = useState("");
        useEffect(() => {
            document.title = title;
            console.log('re-render');
            
        });

        return (
            <div>
            <input
                type="text"
                value={title}
                onChange={(e) => setTitle(e.target.value)}
            />
            </div>
        );
    }
    ```
2. Call API (khi gọi fetch re-render sẽ bị gọi lại nhiều lần => giảm hiệu suất)
   ```jsx
    export default function Content() {
        let [users, setUsers] = useState([]);
        useEffect(() => {
            fetch("https://jsonplaceholder.typicode.com/users")
            .then((response) => response.json())
            .then((json) => setUsers(json));
        }, []);

        return (
            <div>
            <ul>
                {users.map((u) => (
                <li key={u.id}>{u.name}</li>
                ))}
            </ul>
            </div>
        );
        }
   ```
3. Thay đổi dữ liệu dựa trên tag clicked
   ```jsx
    const types = ["a", "b", "c"];
    export default function Content() {
        let [type, setType] = useState('');
        let [title, setTitle] = useState('');
        useEffect(() => {
            console.log(type);
            setTitle(`You clicked on button ${type}`)
        }, [type]);

        return (
            <div>
            {types.map((type) => (
                <button type="button" key={type} onClick={() => setType(type)}>
                {type}
                </button>
            ))}
            <h2>{title}</h2>
            </div>
        );
    }
   ```
4. Listen DOM event
   - scroll
   - resize
5. Cleanup
   - remove listener/ unsubribe
   - clear timer